[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/QTsaP3S7)
[![Open in Codespaces](https://classroom.github.com/assets/launch-codespace-7f7980b617ed060a017424585567c406b6ee15c891e84e1186181d67ecf80aa0.svg)](https://classroom.github.com/open-in-codespaces?assignment_repo_id=10817060)
# Programming Assignment 2

## Project Goals
The goal of this project is to show proficiency with:
1.	CMake;  
2.  Abstract Base Classes;  
3.  Dynamically allocated objects;  
4.  The const and override keywords;  
5.  Program organization;  

### Important Notes:  
1.	**Formatting**: Make sure that you follow the precise recommendations for the output content and formatting- you will need to run the provided executable to see what output should look like. 
2.	**Comments**: Header comments are required on all files other than the makefile and recommended for the rest of the program. Points will be deducted if no header comments are included.
3.  **Code Reuse**: You are welcome to reuse the supplied code (which is the solution to the first programming assignment) or your own solution to the first programming assignment. Programming assignments 2, 3, 4, and 5 will progressively build on themselves (just like the first assignment). You may reuse your code from each previous assignment, or the solution that I will post at the end of the 3 day late period.
4.  **Grading**:  Code that does not compile and run _will receive a 0_. Additionally, you are expected to use various coding components from CS135, such as prototyping and indenting. Failure to do so will result in a point deduction on the assignment that is not explicitly listed in the assignment rubric. Finally, please remember that the grading scheme for programming assignments has changed. Rather than having checkpoints and no solution, solutions will be released 3 days after the late due date. That means that the remaining assignments (2, 3, 4, and 5) will each be equally weighted at 5% of your final grade, as opposed to the last checkpoint being worth 8% and each previous checkpoint being worth 4%.
5.  **Changes To Documentation**: During the second half of class, you will notice that the directions are significantly less detailed than in the first half- in fact, there won't be any HTML provided. This is to allow you the chance to design the program in a way that makes sense to you. If I do not expicitly tell you what to do, then the implementation is up for interpretation. You may modify existing function parameters and other design elements from part 1 as you see fit.  


## Program  
When complete, your project will contain the following files and directories:  
```
assignment2
    CMakeLists.txt
    customer
        customer.h
        customer.cpp
        CMakeLists.txt
    drink
        drink.h
        drink.cpp
        CMakeLists.txt
    food
        food.h
        food.cpp
        CMakeLists.txt
    helperFunctions
        helperFunctions.cpp
        helperFunctions.h
        CMakeLists.txt
    main
        main.cpp
        loyalty.txt
        CMakeLists.txt
    menuItem
        menuItem.cpp
        menuItem.h
        CMakeLists.txt
    CMakeLists.txt
```

You will have additional files and directories that are generated by running the cmake command, including makefiles. Do **NOT** include these in your push to github.  

Your executable should be named ```meatMob```  

## Programming Problem  
Write a program that loads existing loyalty customer data (see supplied loyalty.txt for format). This file will always have that name, so it should be hardcoded. If the file can be opened for reading, each customer should be read from the loyalty file. The program should prompt users to determine if they are loyalty members. If they say they are, the program should check that they are actually loyalty members by having the user enter their loyalty number and comparing it to existing loyalty members in the database. If they are not a loyalty member, they should be asked if they would like to join. If they are a loyalty member or become a loyalty member, their customer information should be pulled from the array of customers and used to place the order. If they aren't a loyalty member, you should use a default customer. The customer should then be prompted select items for order, until they choose to finish ordering. If they are a loyalty member, they should be asked if they want to use their loyalty points or not. If they do, the cost of the selected item to use the points on should be set to 0. Then the total cost should be calculated and displayed, with the order contents. Then the user should be prompted for the amount they'd like to pay with, and a calculation for change should be done and displayed to the user.   

### The example executable:  
An example executable is provided in this repository. You should be able to run it from your project folder.  
If you encounter a “permission denied” error when attempting to run the executable, type ```chmod u+x restaurantExample``` into the terminal and try running the executable again by doing ```./restaurantExampleP2```. I have provided a standard dev environment executable and a mac m1 chip executable. If your machine cannot run either, please run it in the ECC to see the expected behavior. I suggest running the program a few times with various changes to see how it behaves.    

# The following must be completed by SUNDAY 4/16 at 11:59 PM
This portion is focused on:    
    1) Converting a parent class into an abstract base class, and modifying the associated arrays.  
    2) Modifying child class content interaction with the parent, so that slicing does not occur on child objects stored in the parent array and the child specific attributes can be used in cost calculation.   
    3) Restructuring program code into various directories and files to better understand CMake and file paths.    
    4) Beginning to use dynamic memory allocation.  
    5) Using the const keyword.  

NOTE: you may perform the following parts in any order you would prefer. I provide them as a general guideline and to better separate learning targets.  

**Part 1**  
In this part, you will modify the MenuItem class.  
    1) Add a method to MenuItem named `displayNameAndCost()`. It should display the item's name and cost when called.  
    2) Add a purely virtual method to MenuItem named `calculateMenuItemCost()`.  
    3) Add a purely virtual method to MenuItem named `displayItemInformation()`.  
    4) Modify the `currentOrder` property in the Customer class so that it is an array of MenuItem pointers. This will entail modifying the property's getters and setters, and any other possible references to the currentOrder array (especially in the driver) should be dereferenced before making calls to associated methods.
    5) In the driver, ensure that when you add items to your order, a food item or a drink item is added, NOT a menuItem.  

**Part 2**  
In this part, you will modify the MenuItem's children (Food and Drink) to properly implement the previously declared purely virtual functions in MenuItem, and to perform additional behaviors dependent on their properties.  
    1) Implement `displayItemInformation()` in Food. It should use `displayNameAndCost()` from the parent and then display INGREDIENTS: . Then it should display the ingredients in the food item.  
    2) Implement `displayItemInformation()` in Drink. It should use `displayNameAndCost()` from the parent, and then display INCLUDE: . If the drink has ice, display Ice to the screen. If the drink has a straw, display Straw to the screen.   
    3) Modify Food so that it has two additional properties, availableExtras and numAvailableExtras. Available extras is an array of strings (like ingredients), and numAvailableExtras is the number of extra ingredients available for adding to the order from the array.  
    4) Modify Food so that there are methods named `setAvailableExtras()`, `getAvailableExtras`, and `getNumExtras()`. The two get methods are traditional getters that just return their property. `setAvailableExtras()` should check the item name, and then fill `setAvailableExtras()` with any item available in the other 2 food items that is not normally in that food item. So, for example, if the user wants a Smoked Meat Sandwich, the available extras are BBQ Sauce, Toast, Potatoes, Ranch Dressing, and Broccoli. Then set numAvailableExtras to be equal to the number of items you add to the availableExtras array.  
    5) Implement `calculateMenuItemCost()` in Food. It should update the cost of the item. Each ingredient added to the item should cost .50 cents, and should be added to the overall cost of the item. **NOTE**: don't forget that multiplying a float or double by an int will result in an int.  
    6) Implement `calculateMenuItemCost()` in Drink. 16 oz drinks cost $2.99, 20 oz drinks cost $3.25, and 32 oz drinks cost $3.75. If the user wants a straw, they should be charged an additional .75 cents. If the user wants ice, they should be charged an additional .25 cents.  
    7) Use the override keyword on each of the child declarations of the purely virtual methods from MenuItem.  
    8) Modify `displayOrder()` in Customer so that `displayItemInformation()` is called on each item in the current order.  

**Part 3**  
In this part, you will modify getters so that they are const, and setters and parameterized constructors so that the passed values are const.   
    1) Modify getters so that they are const methods- not all getters (specifically ones that return pointers) should be const.  
    2) Modify all setters and parameterized constructors so that their parameters are const.  

**Part 4**  
In this part you will modify the driver so that the customer can interact with child class properties. NOTE: in order for changes to persist outside of scope, objects should be passed by address or reference.  
    1) Add a function named `promptFoodAddOns()`. It should ask the user if they want to add an ingredient to the item that will be added to the order. Then it should call `selectIngredient()`.  
    2) Add a function named `selectIngredient()`. It should display all of the available extras to the customer, get their choice, and repeatedly prompt for an ingredient to add until the user chooses to exit. Then it should calculate item cost so that the extra ingredients can be factored into the item cost.  
    3) Add a function named `promptDrinkExtras`. It should prompt for size, and set the drink's size. Then it should ask if the user wants a straw, and set the `needsStraw` property. Finally, it should ask if the user wants ice, and set the `needsIce` property, and call `calculateMenuItemCost()` to update the drink cost using the newly set values.   
    4. Modify `addItemToOrder()` so that the local food and drink variables are dynamically allocated. Failure to do this may result in unanticipated program behavior. Modify each of the food cases that create the different menu items so that foods make a call to `promptForAddons()` before making the call to `addItemToOrder()` on the customer.  Modify the drink case so that `promptDrinkExtras()` is called before making the call to `addItemToOrder()` on the customer.  
    

**Part 5**  
In this part, you will refactor your program file structure to better organize the program, and provide you with file path and CMake experience.  
    1) Use the file hierarchy shown earlier in the readme to reorganize your code into the correct directories. The Customer directory should contain customer.h and customer.cpp, as well as a CMakeLists.txt file, for example. The helperFunctions directory will be empty until step 3. Rename driver.cpp to main.cpp (that's why driver.cpp isn't shown in the hierarchy but main.cpp is).  
    2) Modify each of the included header files so that the path to the file it needs to include is correct. To go up a directory, use `..` and to reference the current directory, `.` can be used. So, for example, Customer needs access to MenuItem.h. The path to MenuItem.h from the directory that contains the customer files is `../menuItem/menuItem.h` rather than `menuItem.h`.  
    3) In the helperFunctions directory, add a file called helperFunctions.h and helperFunctions.cpp . At this point, main.cpp has a very long set of prototypes and function implementations that make it hard to focus on what the main function is doing. Move all of the prototypes, includes, and macro declarations in main to helperFunctions.h, and all of the implementation in main (other than the main function) to helperFunctions.cpp  
    4) Add a file to each directory named CMakeLists.txt (yes, they will all have the same name, just different directories). You can see their locations in the hierarchy above. Following the example from class, implement each directory's CMakeLists.txt file.   
    5) Remove your original makefile, and make sure you have CMake installed- if you don't, do a quick search on how to install it. Run the `CMake .` command from your terminal in your program's root directory. This will generate multiple makefiles (one in each directory). Run the `make` command from your terminal in your program's root directory. This will make the executable, which should be generated in the main directory. If you make changes to a single directory's files, you will only need to run make on that directory after you run the CMake command. There will be an assortment of other cmake files and directories generated- this is normal. **Do NOT submit any CMake file (or makefile) other than CMakeLists.txt**  

**NOTE:** Compilation should result in the same behavior as before, with the additional cost calculations for food and drink, and their altered outputs. Run the provided executable to ensure that you've implemented everything, including error handling.    


## Submission details
Each checkpoint requires you to submit your code through github using the associated github link in webcampus. Make sure you do it by the checkpoint assignment due date! To submit your project, you will have to use git on your VirtualBox installation:
1.	After accepting the assignment invitation, copy the clone URL
2.	Type 
```git clone clone URL```
3.	cd into your new assignment directory
4.	After working on your files
5.	When you’re ready, type the following commands: 
```
git add .
git commit -m “a descriptive message!”
git push
```
## Academic Honesty
Academic dishonesty is against university as well as the system community standards. Academic dishonesty includes, but is not limited to, the following:
Plagiarism: defined as submitting the language, ideas, thoughts or work of another as one's own; or assisting in the act of plagiarism by allowing one's work to be used in this fashion.
Cheating: defined as (1) obtaining or providing unauthorized information during an examination through verbal, visual or unauthorized use of books, notes, text and other materials; (2) obtaining or providing information concerning all or part of an examination prior to that examination; (3) taking an examination for another student, or arranging for another person to take an exam in one's place; (4) altering or changing test answers after submittal for grading, grades after grades have been awarded, or other academic records once these are official.
Cheating, plagiarism or otherwise obtaining grades under false pretenses constitute academic
dishonesty according to the code of this university. Academic dishonesty will not be tolerated and
penalties can include cancelling a student’s enrolment without a grade, giving an F for the course, or for the assignment. For more details, see the University of Nevada, Reno General Catalog.
